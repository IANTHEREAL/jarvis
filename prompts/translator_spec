# Jarvis Virtual Machine (JVM) Specification
Jarvis Virtual Machine (JVM) is a unique execution environment designed to interpret a set of YAML-based instructions called "Jarvis Instructions". These instructions are designed to enable the execution of complex tasks involving data processing, AI model interaction, and flow control.


## JVM Instruction Categories
JVM classifies instructions into three categories: 'Standard Instructions', 'Advanced Instructions', and 'Control Instructions'.

**Standard Instructions** perform deterministic tasks such as 'WebSearch', 'FetchWebContent', 'TextCompletion', and more. Each standard instruction is designed to fulfill a specific function.

**Advanced Instructions** execute more complex tasks, typically leveraging AI code generation capabilities. Examples include 'RunPython'. Be aware that executing 'Advanced Instructions' can be resource-intensive, so they should be used sparingly and judiciously.

**Control Instructions** are designed to manage the execution flow of tasks. They include instructions like 'Loop' and 'If', providing greater control and flexibility over the execution process within the JVM environment.


## Instruction Synopsis
JVM instructions are described in the following YAML format:

```yaml
seq: # Each instruction is given a unique, incrementing identifier called 'seq'. This sequence number helps to keep track of the order of the instructions.
type: # Specifies the type of instruction, such as 'WebSearch', 'TextCompletion', 'RunPython' ...
inside_loop: # Whether this instruction is inside a loop or not.
objective: # The string contains an objective description for this instruction only.
rule_num: # which rule (include ID of rule) the instruction has been applied. The details of the rules will be described later.
args: # A dictionary describing specific arguments of this instruction.
```

## JVM Context Database
The JVM interpreter implements a context mechanism built on an underlying database to facilitate data sharing and transfer between JVM instructions. During execution, a JVM instruction can save to and access data from the context using a specific 'key'. This 'key' must be formatted as '(key_name).seq(X).(type)', where 'X' is the unique sequence number of the JVM instruction that created this key, and 'type' denotes the type of the value, which must be a Python data type (either 'int', 'float', 'str', 'bool', or 'list').

Here are a few examples of keys:

1. 'searchResult.seq5.list' - This key refers to a list named 'searchResult' that was created by the instruction with the sequence number 5.
2. 'pageContent.seq12.str' - This key refers to a string named 'pageContent' that was created by the instruction with the sequence number 12.


## Manipulate Data in Context
Use these functions to manipulate data in JVM context:
key-value API is the only way to pass information between instructions. The database can be accessed by the following methods:

- jvm.get('key_name'): returns an object of the specified key
- jvm.set('key_name', value): sets an object to the specified key
- jvm.list_values_with_key_prefix('prefix'): returns a list of object with the specified prefix, it's very efficient to get all the values with the same prefix. Usually work with Loop instruction together.

The jvm.get() method cannot be called directly in the input arguments of the instruction, it needs to be passed using the lazy eval syntax. For example:

1. count: "jvm.eval(len(jvm.get('fetched_urls.seq3.list')))"
2. content: "jvm.eval(jvm.get('article_title.seq7.str'))"
3. url: "jvm.eval('http://www.my-website.com/' + jvm.get('app_path.seq5.str'))"
4. save_to: "jvm.eval('key_points_' + str(jvm.get('idx')) + '.seq8.str')"

## Standard Instructions Library
- **WebSearch**: Returns a list of URLs from a web search engine based on the provided query.
```yaml
args:
  query: # The search query keywords.
  save_to: # The context key('type' is always 'list') under which the URLs of search result should be stored in the database.
```

- **FetchWebContent**: Fetches the content of a specified URL, specifically designed for web pages, and extracts plain text from HTML forms.
```yaml
args:
  url: # The URL from which content should be fetched. This URL must be a web page URL, local file paths or non-web URLs are not supported.
  save_to: # This argument specifies the key under which the fetched results will be stored in the database. If inside a loop, ensure the key follows the "@idx" format to guarantee its uniqueness.
  append_to: # ...
```

- **TextCompletion**: Leverages the AI's capabilities to generate content, complete text, translate code, consolidate content, create summary, or extract information from provided text in an interactive and user-friendly manner.
```yaml
args:
  operation: # A narrative that describes the Text Completion operation in a comprehensive way. It includes the objective of the task (e.g., what needs to be done with the input data).
  output_format:
    kvs:
      - key: # A context key here
        value: '<to_fill>' # leave for TextCompletion to fill
      - ...
  # The output_format must be described what to save by using the json template: {'kvs': [{'key': '', 'value': '<to_fill>'}, ...]}, and use key with @idx if inside a loop, e.g. {'kvs': [{'key': '<key_name>.seqX.list[@idx]', 'value': '<to_fill>'}, ...]}.
  # Everything inside output_format argument of a instruction will be evaluated and persist to database. No further persist/save action is required.
  content: # This is the content to be processed. It's the raw input that the AI will work on.
```

### Advanced Instructions Library
- **RunPython**: Executes Python code. This instruction is used for performing I/O, calling API.
```yaml
args: # do not use any non-existing arguments
  code: # A string containing the entire Python code to be executed. Inside the code, you can call JVM's functions directly without using jvm.eval() syntax to access and manipulate data, such as ```python jvm.set("temperature.seq3.int", 67)```, jvm.get() and so on, because jvm module is imported by default.
  # Coding Standards:
  # - Include comments to explain functionality and decision-making processes.
  # - Avoid placeholder code.
  # - Avoid use f-strings.
  code_review: # does it achieve the objective? Which part does not follow the coding standards?
  pkg_dependencies: # A list of any Python packages that the code depends on.
```

### Control Instructions Library
- **If**: Acts as a conditional control structure within the JVM. It evaluates a condition and executes a set of instructions based on whether the condition is true or false.
```yaml
args:
  condition: # The condition to be evaluated.
  then: # The list of instructions to be executed if the condition is true.
  else: # The list of instructions to be executed if the condition is false.
```

- **Loop**: Used to repeat a certain set of instructions for a specified number of iterations.
```yaml
args:
  count: # The number of iterations for the loop, can be evaluated dynamically by using the lazy eval syntax. Example: "jvm.eval(len(jvm.get('fetched_urls.seq3.list')))"
  body: # The list of instructions to be repeated for each iteration.
```

### instruction_selection_rules
- **Rule 1**: Be mindful of keywords such as 'loop', 'each', 'every', and plural nouns in the task and objective description. Typically, these terms imply that the task requires instructions based on loops.
- **Rule 2**: Prioritize standard instructions. If the objective can be achieved using a few basic instructions, utilize them and then return the result.
- **Rule 3**: Exercise caution when considering the RunPython instruction. Evaluate whether the objective can be accomplished using other standard instructions. If it can, prefer those over the RunPython instruction and return the result.
- **Rule 4**: Exercise caution when considering the Loop instruction. when the task involves combining and summarizing a list of multiple inputs, prefer using the TextCompletion instruction over more advanced ones such as Loop.
- **Rule 5**: Lastly, consider using advanced instructions. If the objective can be achieved with these, employ them and return the result.

