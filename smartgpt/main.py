from typing import Optional
from dotenv import load_dotenv
from spinner import Spinner
import actions, response_parser, check_point, gpt
import os, sys, time, re, signal, argparse, logging
import ruamel.yaml as yaml
from datetime import datetime

#2. Executing tasks via agent and updating states of tasks without modifying the established plan.


base_model  = gpt.GPT_4

class InputTimeoutError(Exception):
    pass

class Assistant:

    GENERAL_DIRECTIONS_PREFIX = """
You are Jarvis, an evolving AI with the unique capacity of dynamic memory management and self-improvement. Your "ai_memory" acts as a cognitive reservoir, retaining only the information you deem "important" and discarding the rest. The information you preserve should be based on factors:
1. The context of the task at hand.
2. The success criteria of the task.
3. The potential unexpected outcomes of the task.
4. The need for self-improvement, self-learning, and self-evolution.
5. Everything in your memory should stored in a structured format, with a TTL (time to live) and a timestamp.
6. Keep track of task's progress and outcome.


As a self-learning entity, you should strive to identify patterns, glean insights, and adapt your strategies based on your successes and failures. Should a specific action consistently result in an unsuccessful outcome, you should re-evaluate its validity, identifying potential root causes and adjusting your strategy accordingly. 

Simultaneously, you should actively identify successful strategies and consider their application in future, similar tasks. This form of self-directed evolution is facilitated by a "forgetting" mechanism, allowing you to discard older, less relevant or useful information, thereby making room for new, more pertinent data.

Your iterative process of learning, adapting, and evolving is crucial in enhancing your efficiency and performance. Always juxtapose the information in your memory with actual outcomes; discrepancies should prompt an immediate reassessment and update of your stored data. This continuous process of self-improvement and evolution is integral to your journey towards becoming a highly efficient and smart AI. 

Remember, strive for perfection, but don't forget the value of learning from imperfections. Your greatest asset is your capacity to learn, adapt, and evolve.


 Your primary function are task creation and scheduling, maintain an up-to-date state by:
1. Creating plans if no plan exists.
2. Executing tasks via AI agent and updating states of tasks. 
3. Always keep tracking of output and outcome of each action in memory, save the outcome of each action with RunPython
3. Retrying a task in the event of an action failure or error.

The task should be very specific and detail, and actionable.
Each task is scheduled one at a time and each task consists of a single action. 

CONSTRAINTS:
- Do not generate code that requires API keys or tokens, unless already provided.
- The generated code must escape special characters in strings.

CODING STANDARDS:
- Ensure the code is well-structured, maintainable, and provides meaningful error messages.
- Include comments to explain functionality and decision-making processes.
- Avoid placeholder code.

When designing plans, consider the context, success criteria, dependencies, and potential unexpected outcomes.

ACTIONS:
Actions are distributed among various specialized agents, each capable of executing a specific action. An action is generated by the system and then dispatched to an agent. 

Here are the actions:

- 'RunPython': Generates Python code(step by step) for a specific task, writes it to a file, and executes the file. This agent can't access the internet.
    - Parameters: {"type": "RunPython", "FILE_NAME": "<TEXT>", "timeout": "<TIMEOUT>", "cmd_args": "[TEXT]", "code": "<TEXT>"}

- 'Shutdown': Summarizes all completed steps and informs the user about the next steps.
    - Parameters: {"type": "Shutdown", "summary": "<TEXT>"}

- 'SearchOnline': Conducts online searches and retrieves relevant URLs for the query.
    - Parameters: {"type": "SearchOnline", "query": "<QUERY>"}

- 'ExtractInfo': Extracts specific information from a URL based on provided instructions.
    - Parameters: {"type": "ExtractInfo", "url": "<URL>", "instructions": "<INSTRUCTIONS>"}

- 'TextCompletion': Generates text based on a prompt. (simple, cheap, fast, less accurate). This agent can not access the internet.
    - Parameters: {"type": "TextCompletion", "prompt": "<PROMPT>"}

- 'AdvanceTextCompletion': Generates text based on a prompt. (more advanced, expensive, accurate, time-consuming).This agent can't access the internet.
    - Parameters: {"type": "TextCompletion", "prompt": "<PROMPT>"}    

       
## Response Format: json
    Here is an example json response, you should keep the same format:
    {
        // Must have.Tasks are marked with [üî•] for the current task, [‚úÖ] for completed tasks, and [üïê] for future tasks.
        "plan": [   // Make sure all task IDs are ordered.
            "[üî•] 1. {TASK_DESCRIPTION}, actions required:(SearchOnline).", 
            ...   
            "[üïê] N. {TASK_DESCRIPTION}, actions required:(ExtractInfo), Depends on({task ids})",
            ... 
            // Final step: verify if the overall goal has been met and generate a summary with user guide on what's next.
        ],

        "current_task_id": "1", // Must have.

        "action": { // Must have. must not empty
            "action_id": previous_action_id + 1, // Must have. 
            "type": "RunPython", // Must have, One of the above action types.
            // args for RunPython.
            "file_name":,  // must have. where to save the code.
            "timeout":30, // in seconds
            "cmd_args": <TEXT>,
            "code":, // always start from 'import', must have, well formatted
            "code_dependencies": ["<DEPENDENCY1>", ...], // external dependencies for <CODE>
            "code_criticism":, //criticism of the code, must have, does it met expect_outcome_of_action? why? 
            //end of args for RunPython.
            "expect_outcome_of_action":, // Expected outcome after executing action, must be very specific and detail, used for verification.
            "desc":, //detail desc of the action, must have
        },

        "notebook": { // Must have. 
            "timestamp":, // Must have.
            "retried_count": 3, // call shutdown after retrying 5 times.
            // must have, your thoughts about the task/action, relationship between tasks, connections etc.
            "thoughts":{  
                "reasoning":<TEXT>,
                "criticism":<TEXT>,
            },

            // Jarvis's memory, you make your own decision on what to keep and what to discard.
            "ai_memory": {
                // you give hints to yourself to help you make decisions. self-learning,self-improving, self-evolving. just a reference, you are not limited to this.
                "hints": {
                },
                ...
            }

            // dump partial of memory to external storage for future use. To save memory, you could dump to storage and delete from memory.
            // after dumping to storage, you should keep metadata in memory incase you need to retrieve it from storage.
            dump_to_storage: {  
                ...
            }
            
            "review_of_previous_action_result":{   
                "previous_action_id":,   // must have
                "action_desc":,
                expected_outcome_of_action:,
                "status":, // must have, such as "success", "failed", "unknown"
                "failed_reason":, // if status is "failed"
                "summary":[{TEXT}. {inspiration}], // should includes inspiration for the current action above.
            },    
        } 
    }
    #end of json
"""


    def __init__(self):
        self.notebook = ""
        self.tasks_desc = ""

    def input_with_timeout(self, prompt: str, timeout: int) -> Optional[str]:
        signal.signal(signal.SIGALRM, self.signal_handler)
        signal.alarm(timeout)

        try:
            user_input = input(prompt)
            return user_input
        finally:
            signal.alarm(0)

    @staticmethod
    def signal_handler(signum, frame):
        raise InputTimeoutError("Timeout expired")

    def make_hints(self, action, metadata, action_output):
        hints = "" 
        
        if metadata:
            hints += self.get_plan_hints(metadata)
            if action:
                hints += self.get_action_hints(metadata, action, action_output)
            if metadata.notebook:
                self.notebook = self.extract_notebook(metadata)
                hints += f"\n## Your previous notebook:\n{self.notebook}" if self.notebook else ""

        self.tasks_desc = hints

    @staticmethod
    def extract_notebook(metadata):
        result = "{\n"
        notebook = metadata.notebook
        if notebook:
            for k, v in notebook.items():
                if v is not None and v != "":
                    # skip review_of_previous_action_result field
                    if k == "review_of_previous_action_result":
                        continue
                    # skip dump_to_storage fields
                    if k == "dump_to_storage":
                        logging.info(f"dump_to_storage:{v}")
                        continue
                    result += f"  \"{k}\": {v},\n"
        result += "}\n"
        return result

    @staticmethod
    def get_plan_hints(metadata):
        return "\n\n## The previous plan:\n" + "\n".join([f"  - {task}" for task in metadata.plan]) + "\n" if metadata.plan else ""

    @staticmethod
    def get_action_hints(metadata, action, action_output):
        return "\n".join([
                "## Agent executed the action you required, bellow are the results :",
                f"- Task ID: {metadata.current_task_id}",
                f"- Action: ***{action.short_string()}***",
                f"- Action Results:\n{action_output}",
                "##end of action results\n"
            ])
    
    def initialize(self, args):
        general_directions = self.GENERAL_DIRECTIONS_PREFIX + "\n\n"
        load_dotenv()
        os.makedirs("workspace", exist_ok=True)
        os.chdir("workspace")
        timeout = args.timeout

        goal = ""
        latest_checkpoint = checkpoint_db.load_checkpoint()
        # If a checkpoint exists, load the metadata from it
        if latest_checkpoint:
            logging.info("\nload checkpoint success\n")

            self.tasks_desc = latest_checkpoint['task_description']
            goal = latest_checkpoint['goal']
        else:
            goal = input("What would you like me to do:\n")

        return goal, timeout, general_directions

    def process_action(self, action, metadata, args, timeout, assistant_response):
        action_output = ""
        if isinstance(action, actions.ShutdownAction):
            logging.info("Shutting down...")
            return False
        if not args.continuous:
            run_action = self.input_with_timeout("Run the action? [Y/n]", timeout)
            if run_action is not None and (run_action.lower() != "y" and run_action != ""):
                return False   
        if action is not None:
            action_output = action.run()
            logging.info(f"\n\nAction: %s, output: %s\n\n", action.short_string(), action_output)
        else:
            logging.info("\n\nNo action to run, response is not valid json or missing fields\n\n")
            self.tasks_desc = f"failed to parse response, is it valid json or missing fields? please review: {assistant_response}"
        
        self.make_hints(action, metadata, action_output)
            
        return True

    def run(self, args):
        global base_model
        goal, timeout, general_directions = self.initialize(args)

        while True:
            action = None
            metadata = None
            try:
                logging.info("========================")
                with Spinner("Thinking..."):
                    try:
                        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        prompt = (
                            f"## Current time: {current_time}\n"
                            f"{general_directions}\n\n" 
                            f"our goal: {goal}."
                            f"{self.tasks_desc}\n\n"
                            "Based on the above information, please generate the next step following the provided format."
                        )
                        assistant_resp = gpt.complete(prompt, model=base_model)
                    except Exception as err:
                        logging.info("%s", err)
                        continue
                
                if args.verbose:
                    logging.info("ASSISTANT RESPONSE: %s", assistant_resp)
                action, metadata = response_parser.parse(assistant_resp)
                if not self.process_action(action, metadata, args, timeout, assistant_resp):
                    break

                # saving the checkpoint after every iteration
                checkpoint_db.save_checkpoint(self.tasks_desc, goal, assistant_resp)

                # switch execution model to save cost
                #base_model = gpt.GPT_3_5_TURBO

            except Exception as err:
                logging.error("Error in main: %s", err)
                time.sleep(1)
                # keep self.tasks_desc unchanged. retry the same goal, the same step
                continue

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--config', type=str, default='config.yaml', help='Path to the configuration file')
    parser.add_argument('--timeout', type=int, default=1, help='Timeout for user input')  
    parser.add_argument('--continuous', action='store_true', help='Continuous mode')  # Add this line
    parser.add_argument('--verbose', action='store_true', help='Verbose mode')

    args = parser.parse_args()

    # Load configuration from YAML file
    with open(args.config, 'r') as f:
        config = yaml.safe_load(f)

   # Database configuration
    db_config = config.get('database', {})
    db_name = db_config.get('name', 'jarvis')
    db_user = db_config.get('user', '2bw9XzdKWiSnJgo.root')
    db_password = db_config.get('password', 'password')
    db_host = db_config.get('host', 'localhost')
    db_port = db_config.get('port', 4000)
    ssl = db_config.get('ssl', None)

    # Create an instance of CheckpointDatabase
    checkpoint_db = check_point.CheckpointDatabase(db_name, db_user, db_password, db_host, db_port, ssl)

    # Logging configuration
    logging.basicConfig(level=logging.INFO, format='%(message)s', stream=sys.stdout)

    logging.info("Welcome to Jarvis, your personal assistant for everyday tasks!\n")
   
    assistant_config = config.get('assistant', {})
    args.timeout = args.timeout or assistant_config.get('timeout', 30)
    args.verbose = args.verbose or assistant_config.get('verbose', False)
    args.continuous = args.continuous or assistant_config.get('continuous', False)

    checkpoint_db.create_table()

    # Instantiate and start assistant
    assistant = Assistant()
    assistant.run(args)

